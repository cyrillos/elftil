#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <stdint.h>

#include <fcntl.h>
#include <elf.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>

#include "compiler.h"
#include "elftil.h"
#include "types.h"
#include "util.h"
#include "log.h"

int handle_elf(const opt_t *opts, char *mem, size_t size)
{
	Ehdr_t *hdr = (void *)mem;
	Shdr_t *symtab_hdr = NULL;
	Sym_t *symbols = NULL;
	const char *symstrings = NULL;

	Shdr_t *strtab_hdr = NULL;
	Shdr_t *secstrings_hdr = NULL;
	Shdr_t **sec_hdrs = NULL;
	const char *secstrings;

	size_t i, k, nr_gotpcrel = 0;

	pr_debug("Header\n------------\n");
	pr_debug("\ttype 0x%x machine 0x%x version 0x%x\n",
		 hdr->e_type, hdr->e_machine, hdr->e_version);

#ifdef CONFIG_X86_64
	if (hdr->e_type != ET_REL	||
	    hdr->e_machine != EM_X86_64	||
	    hdr->e_version != EV_CURRENT) {
		pr_err("Unsupported header detected\n");
		goto err;
	}
#endif

#ifdef CONFIG_X86_32
	if (hdr->e_type != ET_REL	||
	    hdr->e_machine != EM_386	||
	    hdr->e_version != EV_CURRENT) {
		pr_err("Unsupported header detected\n");
		goto err;
	}
#endif

	sec_hdrs = malloc(sizeof(*sec_hdrs) * hdr->e_shnum);
	if (!sec_hdrs) {
		pr_err("No memory for section headers\n");
		goto err;
	}

	secstrings_hdr = (void *)mem + hdr->e_shoff + hdr->e_shentsize * hdr->e_shstrndx;
	secstrings = (void *)mem + secstrings_hdr->sh_offset;
	ptr_func_exit(secstrings_hdr);
	ptr_func_exit(secstrings);

	pr_debug("Sections\n------------\n");
	for (i = 0; i < hdr->e_shnum; i++) {
		Shdr_t *sh = (void *)mem + hdr->e_shoff + hdr->e_shentsize * i;
		ptr_func_exit(sh);

		if (sh->sh_type == SHT_SYMTAB)
			symtab_hdr = sh;

		ptr_func_exit(&secstrings[sh->sh_name]);
		pr_debug("\t index %-2d type 0x%-2x name %s\n",
			 i, sh->sh_type, &secstrings[sh->sh_name]);

		sec_hdrs[i] = sh;
	}

	if (!symtab_hdr) {
		pr_err("No symbol table present\n");
		goto err;
	}

	if (!symtab_hdr->sh_link || symtab_hdr->sh_link >= hdr->e_shnum) {
		pr_err("Corrupted symtab header\n");
		goto err;
	}

	pr_debug("Symbols\n------------\n");
	strtab_hdr = sec_hdrs[symtab_hdr->sh_link];
	ptr_func_exit(strtab_hdr);

	symbols = (void *)mem + symtab_hdr->sh_offset;
	symstrings = (void *)mem + strtab_hdr->sh_offset;
	ptr_func_exit(symbols);
	ptr_func_exit(symstrings);

	if (sizeof(*symbols) != symtab_hdr->sh_entsize) {
		pr_err("Symbol table align differ\n");
		goto err;
	}

	pr_out("/* Autogenerated from %s */\n", opts->input_filename);
	for (i = 0; i < symtab_hdr->sh_size / symtab_hdr->sh_entsize; i++) {
		Sym_t *sym = &symbols[i];
		Shdr_t *sh_src;
		const char *name;

		ptr_func_exit(sym);
		name = &symstrings[sym->st_name];
		ptr_func_exit(name);

		if (*name) {
			pr_debug("\ttype 0x%-2x bind 0x%-2x shndx 0x%-4x value 0x%-2x name %s\n",
				 ELF_ST_TYPE(sym->st_info),
				 ELF_ST_BIND(sym->st_info),
				 sym->st_shndx, sym->st_value,
				 name);
			if (sym->st_shndx && sym->st_shndx < hdr->e_shnum) {
				sh_src = sec_hdrs[sym->st_shndx];
				ptr_func_exit(sh_src);
				if (ELF_ST_TYPE(sym->st_info) == STT_FUNC ||
				    ELF_ST_TYPE(sym->st_info) == STT_OBJECT)
					pr_out("#define %s%s 0x%x\n",
					       name, opts->sym_postfix,
					       sym->st_value + sh_src->sh_offset);
			}
		}
	}

	pr_out("typedef struct {\n"
	       "	unsigned int	offset;\n"
	       "	unsigned int	type;\n"
	       "	long		addend;\n"
	       "	long		value;\n"
	       "} %s;\n%s %s[] = {\n",
	       opts->type_name, opts->type_name, opts->var_name);

	pr_debug("Relocations\n------------\n");
	for (i = 0; i < hdr->e_shnum; i++) {
		Shdr_t *sh = sec_hdrs[i];
		Shdr_t *sh_rel;

		if (sh->sh_type != SHT_REL && sh->sh_type != SHT_RELA)
			continue;

		sh_rel = sec_hdrs[sh->sh_info];
		ptr_func_exit(sh_rel);

		pr_debug("\tsection %2d type 0x%-2x link 0x%-2x info 0x%-2x name %s\n", i,
			 sh->sh_type, sh->sh_link, sh->sh_info, &secstrings[sh->sh_name]);

		for (k = 0; k < sh->sh_size / sh->sh_entsize; k++) {
			Shdr_t *sh_src;
			s64 addend64, place, value64;
			Sym_t *sym;
			s32 addend32, value32;
			const char *name;
			void *where;
			union {
				Rel_t rel;
				Rela_t rela;
			} *r = (void *)mem + sh->sh_offset + sh->sh_entsize * k;
			ptr_func_exit(r);

			sym = &symbols[ELF_R_SYM(r->rel.r_info)];
			ptr_func_exit(sym);
			name = &symstrings[sym->st_name];
			ptr_func_exit(name);
			where = (void *)mem + sh_rel->sh_offset + r->rel.r_offset;
			ptr_func_exit(where);
			sh_src = sec_hdrs[sym->st_shndx];
			ptr_func_exit(sh_src);

			pr_debug("\t\tr_offset 0x%-4x r_info 0x%-4x / sym 0x%-2x type 0x%-2x symsecoff 0x%-4x\n",
				 r->rel.r_offset, r->rel.r_info,
				 ELF_R_SYM(r->rel.r_info),
				 ELF_R_TYPE(r->rel.r_info),
				 sh_src->sh_offset);

			if (sym->st_shndx == SHN_UNDEF)
				continue;

			ptr_func_exit(((void *)mem + sh_rel->sh_offset + r->rel.r_offset));
			if (sh->sh_type == SHT_REL) {
				addend32 = *(s32 *)where;
				addend64 = *(s64 *)where;
			} else {
				addend32 = (s32)r->rela.r_addend;
				addend64 = (s64)r->rela.r_addend;
			}

			place = (long)(where - (void *)mem);

			pr_debug("\t\t\tvalue 0x%-8x addend32 %-4d addend64 %-8d symname %s\n",
				 sym->st_value, addend32, addend64, name);

			value32 = (s32)sh_src->sh_offset + (s32)sym->st_value;
			value64 = (s64)sh_src->sh_offset + (s64)sym->st_value;

			switch (ELF_R_TYPE(r->rel.r_info)) {
#ifdef CONFIG_X86_64
			case R_X86_64_32: /* Symbol + Addend (4 bytes) */
				pr_debug("\t\t\t\tR_X86_64_32   at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32);
				pr_out("	{ .offset = 0x%-8x, .type = 0, .addend = 0       , .value = 0x%-16x, }, /* R_X86_64_32 */\n",
				       (unsigned int)place, value32 + addend32);
				break;
			case R_X86_64_64: /* Symbol + Addend (8 bytes) */
				pr_debug("\t\t\t\tR_X86_64_64   at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value64);
				pr_out("	{ .offset = 0x%-8x, .type = 1, .addend = 0       , .value = 0x%-16x, }, /* R_X86_64_64 */\n",
				       (unsigned int)place, value64 + addend64);
				break;
			case R_X86_64_PC32: /* Symbol + Addend - Place (4 bytes) */
				pr_debug("\t\t\t\tR_386_PC32 at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32 + addend32 - place);
				/*
				 * R_X86_64_PC32 are relative, patch them inplace.
				 */
				*((s32 *)where) = value32 + addend32 - place;
				break;
			case R_X86_64_PLT32: /* ProcLinkage + Addend - Place (4 bytes) */
				pr_debug("\t\t\t\tR_386_PLT32 at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32 + addend32 - place);
				/*
				 * R_X86_64_PLT32 are relative, patch them inplace.
				 */
				*((s32 *)where) = value32 + addend32 - place;
				break;
			case R_X86_64_GOTPCREL: /* SymbolOffsetInGot + GOT + Addend - Place  (4 bytes) */
				pr_debug("\t\t\t\tR_X86_64_GOTPCREL at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32);
				pr_out("	{ .offset = 0x%-8x, .type = 3, .addend = %-8d, .value = 0x%-16x, }, /* R_X86_64_GOTPCREL */\n",
				       (unsigned int)place, addend32, value32);
				nr_gotpcrel++;
				break;
#endif
#ifdef CONFIG_X86_32
			case R_386_32: /* Symbol + Addend */
				pr_debug("\t\t\t\tR_386_32   at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32 + addend32);
				pr_out("	{ .offset = 0x%-8x, .type = 0, .addend = %-4d, .value = 0x%x, },\n",
				       (unsigned int)place, addend32, value32);
				break;
			case R_386_PC32: /* Symbol + Addend - Place */
				pr_debug("\t\t\t\tR_386_PC32 at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32 + addend32 - place);
				/*
				 * R_386_PC32 are relative, patch them inplace.
				 */
				*((s32 *)where) = value32 + addend32 - place;
				break;
#endif
			default:
				pr_err("Unsupported relocation\n");
				goto err;
			}
		}
	}
	pr_out("};\n");
	pr_out("static size_t %s = %d;\n", opts->nrgotpcrel_name, nr_gotpcrel);

	pr_out("const char %s[] = {\n\t", opts->stream_name);
	for (i = 0; i < size; i++) {
		if (i && (i % 8) == 0)
			pr_out("\n\t");
		pr_out("0x%02x,", ((unsigned char *)mem)[i]);
	}
	pr_out("};\n");
err:
	free(sec_hdrs);
	return -1;
}
