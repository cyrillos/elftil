#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <stdint.h>
#include <getopt.h>

#include <fcntl.h>
#include <elf.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>

#include "compiler.h"
#include "types.h"
#include "util.h"
#include "log.h"

struct opts_s {
	char		*input_filename;
	char		*stream_name;
	char		*type_name;
	char		*var_name;
	char		*sym_postfix;
	char		*nrgotpcrel_name;
} opts = {
	.input_filename	= "file.o",
	.stream_name	= "stream",
	.type_name	= "elf_reloc_t",
	.var_name	= "elf_relocs",
	.sym_postfix	= "_sym",
	.nrgotpcrel_name= "nr_gotpcrel",
};

static int handle_elf64(const struct opts_s *opts, char *mem, size_t size)
{
	Elf64_Ehdr *hdr = (void *)mem;
	Elf64_Shdr *symtab_hdr = NULL;
	Elf64_Sym *symbols = NULL;
	const char *symstrings = NULL;

	Elf64_Shdr *strtab_hdr = NULL;
	Elf64_Shdr *secstrings_hdr = NULL;
	Elf64_Shdr **sec_hdrs = NULL;
	const char *secstrings;

	size_t i, k, nr_gotpcrel = 0;

	pr_debug("Header\n------------\n");
	pr_debug("\ttype 0x%x machine 0x%x version 0x%x\n",
		 hdr->e_type, hdr->e_machine, hdr->e_version);

	if (hdr->e_type != ET_REL	||
	    hdr->e_machine != EM_X86_64	||
	    hdr->e_version != EV_CURRENT) {
		pr_err("Unsupported header detected\n");
		goto err;
	}

	sec_hdrs = malloc(sizeof(*sec_hdrs) * hdr->e_shnum);
	if (!sec_hdrs) {
		pr_err("No memory for section headers\n");
		goto err;
	}

	secstrings_hdr = (void *)mem + hdr->e_shoff + hdr->e_shentsize * hdr->e_shstrndx;
	secstrings = (void *)mem + secstrings_hdr->sh_offset;
	ptr_func_exit(secstrings_hdr);
	ptr_func_exit(secstrings);

	pr_debug("Sections\n------------\n");
	for (i = 0; i < hdr->e_shnum; i++) {
		Elf64_Shdr *sh = (void *)mem + hdr->e_shoff + hdr->e_shentsize * i;
		ptr_func_exit(sh);

		if (sh->sh_type == SHT_SYMTAB)
			symtab_hdr = sh;

		ptr_func_exit(&secstrings[sh->sh_name]);
		pr_debug("\t index %-2d type 0x%-2x name %s\n",
			 i, sh->sh_type, &secstrings[sh->sh_name]);

		sec_hdrs[i] = sh;
	}

	if (!symtab_hdr) {
		pr_err("No symbol table present\n");
		goto err;
	}

	if (!symtab_hdr->sh_link || symtab_hdr->sh_link >= hdr->e_shnum) {
		pr_err("Corrupted symtab header\n");
		goto err;
	}

	pr_debug("Symbols\n------------\n");
	strtab_hdr = sec_hdrs[symtab_hdr->sh_link];
	ptr_func_exit(strtab_hdr);

	symbols = (void *)mem + symtab_hdr->sh_offset;
	symstrings = (void *)mem + strtab_hdr->sh_offset;
	ptr_func_exit(symbols);
	ptr_func_exit(symstrings);

	if (sizeof(*symbols) != symtab_hdr->sh_entsize) {
		pr_err("Symbol table align differ\n");
		goto err;
	}

	pr_out("/* Autogenerated from %s */\n", opts->input_filename);
	for (i = 0; i < symtab_hdr->sh_size / symtab_hdr->sh_entsize; i++) {
		Elf64_Sym *sym = &symbols[i];
		Elf64_Shdr *sh_src;
		const char *name;

		ptr_func_exit(sym);
		name = &symstrings[sym->st_name];
		ptr_func_exit(name);

		if (*name) {
			pr_debug("\ttype 0x%-2x bind 0x%-2x shndx 0x%-4x value 0x%-2x name %s\n",
				 ELF64_ST_TYPE(sym->st_info),
				 ELF64_ST_BIND(sym->st_info),
				 sym->st_shndx, sym->st_value,
				 name);
			if (sym->st_shndx && sym->st_shndx < hdr->e_shnum) {
				sh_src = sec_hdrs[sym->st_shndx];
				ptr_func_exit(sh_src);
				if (ELF64_ST_TYPE(sym->st_info) == STT_FUNC ||
				    ELF64_ST_TYPE(sym->st_info) == STT_OBJECT)
					pr_out("#define %s%s 0x%x\n",
					       name, opts->sym_postfix,
					       sym->st_value + sh_src->sh_offset);
			}
		}
	}

	pr_out("typedef struct {\n"
	       "	unsigned int	offset;\n"
	       "	unsigned int	type;\n"
	       "	long		addend;\n"
	       "	long		value;\n"
	       "} %s;\n%s %s[] = {\n",
	       opts->type_name, opts->type_name, opts->var_name);

	pr_debug("Relocations\n------------\n");
	for (i = 0; i < hdr->e_shnum; i++) {
		Elf64_Shdr *sh = sec_hdrs[i];
		Elf64_Shdr *sh_rel;

		if (sh->sh_type != SHT_REL && sh->sh_type != SHT_RELA)
			continue;

		sh_rel = sec_hdrs[sh->sh_info];
		ptr_func_exit(sh_rel);

		pr_debug("\tsection %2d type 0x%-2x link 0x%-2x info 0x%-2x name %s\n", i,
			 sh->sh_type, sh->sh_link, sh->sh_info, &secstrings[sh->sh_name]);

		for (k = 0; k < sh->sh_size / sh->sh_entsize; k++) {
			s32 addend32, value32;
			s64 addend64, place, value64;
			Elf64_Shdr *sh_src;
			const char *name;
			Elf64_Sym *sym;
			void *where;
			union {
				Elf64_Rel rel;
				Elf64_Rela rela;
			} *r = (void *)mem + sh->sh_offset + sh->sh_entsize * k;
			ptr_func_exit(r);

			sym = &symbols[ELF64_R_SYM(r->rel.r_info)];
			ptr_func_exit(sym);
			name = &symstrings[sym->st_name];
			ptr_func_exit(name);
			where = (void *)mem + sh_rel->sh_offset + r->rel.r_offset;
			ptr_func_exit(where);
			sh_src = sec_hdrs[sym->st_shndx];
			ptr_func_exit(sh_src);

			pr_debug("\t\tr_offset 0x%-4x r_info 0x%-4x / sym 0x%-2x type 0x%-2x symsecoff 0x%-4x\n",
				 r->rel.r_offset, r->rel.r_info,
				 ELF64_R_SYM(r->rel.r_info),
				 ELF64_R_TYPE(r->rel.r_info),
				 sh_src->sh_offset);

			if (sym->st_shndx == SHN_UNDEF)
				continue;

			ptr_func_exit(((void *)mem + sh_rel->sh_offset + r->rel.r_offset));
			if (sh->sh_type == SHT_REL) {
				addend32 = *(s32 *)where;
				addend64 = *(s64 *)where;
			} else {
				addend32 = (s32)r->rela.r_addend;
				addend64 = (s64)r->rela.r_addend;
			}

			place = (long)(where - (void *)mem);

			pr_debug("\t\t\tvalue 0x%-8x addend32 %-4d addend64 %-8d symname %s\n",
				 sym->st_value, addend32, addend64, name);

			value32 = (s32)sh_src->sh_offset + (s32)sym->st_value;
			value64 = (s64)sh_src->sh_offset + (s64)sym->st_value;

			switch (ELF64_R_TYPE(r->rel.r_info)) {
			case R_X86_64_32: /* Symbol + Addend (4 bytes) */
				pr_debug("\t\t\t\tR_X86_64_32   at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32);
				pr_out("	{ .offset = 0x%-8x, .type = 0, .addend = 0       , .value = 0x%-16x, }, /* R_X86_64_32 */\n",
				       (unsigned int)place, value32 + addend32);
				break;
			case R_X86_64_64: /* Symbol + Addend (8 bytes) */
				pr_debug("\t\t\t\tR_X86_64_64   at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value64);
				pr_out("	{ .offset = 0x%-8x, .type = 1, .addend = 0       , .value = 0x%-16x, }, /* R_X86_64_64 */\n",
				       (unsigned int)place, value64 + addend64);
				break;
			case R_X86_64_PC32: /* Symbol + Addend - Place (4 bytes) */
				pr_debug("\t\t\t\tR_386_PC32 at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32 + addend32 - place);
				/*
				 * R_X86_64_PC32 are relative, patch them inplace.
				 */
				*((s32 *)where) = value32 + addend32 - place;
				break;
			case R_X86_64_PLT32: /* ProcLinkage + Addend - Place (4 bytes) */
				pr_debug("\t\t\t\tR_386_PLT32 at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32 + addend32 - place);
				/*
				 * R_X86_64_PLT32 are relative, patch them inplace.
				 */
				*((s32 *)where) = value32 + addend32 - place;
				break;
			case R_X86_64_GOTPCREL: /* SymbolOffsetInGot + GOT + Addend - Place  (4 bytes) */
				pr_debug("\t\t\t\tR_X86_64_GOTPCREL at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value32);
				pr_out("	{ .offset = 0x%-8x, .type = 3, .addend = %-8d, .value = 0x%-16x, }, /* R_X86_64_GOTPCREL */\n",
				       (unsigned int)place, addend32, value32);
				nr_gotpcrel++;
				break;
			default:
				pr_err("Unsupported relocation\n");
				goto err;
			}
		}
	}
	pr_out("};\n");
	pr_out("static size_t %s = %d;\n", opts->nrgotpcrel_name, nr_gotpcrel);

	pr_out("const char %s[] = {\n\t", opts->stream_name);
	for (i = 0; i < size; i++) {
		if (i && (i % 8) == 0)
			pr_out("\n\t");
		pr_out("0x%02x,", ((unsigned char *)mem)[i]);
	}
	pr_out("};\n");
err:
	free(sec_hdrs);
	return -1;
}

static int handle_elf32(const struct opts_s *opts, void *mem, size_t size)
{
	Elf32_Ehdr *hdr = mem;
	Elf32_Shdr *symtab_hdr = NULL;
	Elf32_Sym *symbols = NULL;
	const char *symstrings = NULL;

	Elf32_Shdr *strtab_hdr = NULL;
	Elf32_Shdr *secstrings_hdr = NULL;
	Elf32_Shdr **sec_hdrs = NULL;
	const char *secstrings;

	size_t i, k, nr_gotpcrel = 0;

	pr_debug("Header\n------------\n");
	pr_debug("\ttype 0x%x machine 0x%x version 0x%x\n",
		 hdr->e_type, hdr->e_machine, hdr->e_version);

	if (hdr->e_type != ET_REL	||
	    hdr->e_machine != EM_386	||
	    hdr->e_version != EV_CURRENT) {
		pr_err("Unsupported header detected\n");
		goto err;
	}

	sec_hdrs = malloc(sizeof(*sec_hdrs) * hdr->e_shnum);
	if (!sec_hdrs) {
		pr_err("No memory for section headers\n");
		goto err;
	}

	secstrings_hdr = mem + hdr->e_shoff + hdr->e_shentsize * hdr->e_shstrndx;
	secstrings = mem + secstrings_hdr->sh_offset;
	ptr_func_exit(secstrings_hdr);
	ptr_func_exit(secstrings);

	pr_debug("Sections\n------------\n");
	for (i = 0; i < hdr->e_shnum; i++) {
		Elf32_Shdr *sh = mem + hdr->e_shoff + hdr->e_shentsize * i;
		ptr_func_exit(sh);

		if (sh->sh_type == SHT_SYMTAB)
			symtab_hdr = sh;

		ptr_func_exit(&secstrings[sh->sh_name]);
		pr_debug("\t index %-2d type 0x%-2x name %s\n",
			 i, sh->sh_type, &secstrings[sh->sh_name]);

		sec_hdrs[i] = sh;
	}

	if (!symtab_hdr) {
		pr_err("No symbol table present\n");
		goto err;
	}

	if (!symtab_hdr->sh_link || symtab_hdr->sh_link >= hdr->e_shnum) {
		pr_err("Corrupted symtab header\n");
		goto err;
	}

	pr_debug("Symbols\n------------\n");
	strtab_hdr = sec_hdrs[symtab_hdr->sh_link];
	ptr_func_exit(strtab_hdr);

	symbols = mem + symtab_hdr->sh_offset;
	symstrings = mem + strtab_hdr->sh_offset;
	ptr_func_exit(symbols);
	ptr_func_exit(symstrings);

	if (sizeof(*symbols) != symtab_hdr->sh_entsize) {
		pr_err("Symbol table align differ\n");
		goto err;
	}

	pr_out("/* Autogenerated from %s */\n", opts->input_filename);
	for (i = 0; i < symtab_hdr->sh_size / symtab_hdr->sh_entsize; i++) {
		Elf32_Sym *sym = &symbols[i];
		Elf32_Shdr *sh_src;
		const char *name;

		ptr_func_exit(sym);
		name = &symstrings[sym->st_name];
		ptr_func_exit(name);

		if (*name) {
			pr_debug("\ttype 0x%-2x bind 0x%-2x shndx 0x%-4x value 0x%-2x name %s\n",
				 ELF32_ST_TYPE(sym->st_info),
				 ELF32_ST_BIND(sym->st_info),
				 sym->st_shndx, sym->st_value,
				 name);
			if (sym->st_shndx && sym->st_shndx < hdr->e_shnum) {
				sh_src = sec_hdrs[sym->st_shndx];
				ptr_func_exit(sh_src);
				if (ELF32_ST_TYPE(sym->st_info) == STT_FUNC ||
				    ELF32_ST_TYPE(sym->st_info) == STT_OBJECT)
					pr_out("#define %s%s 0x%x\n",
					       name, opts->sym_postfix,
					       sym->st_value + sh_src->sh_offset);
			}
		}
	}

	pr_out("typedef struct {\n"
	       "	unsigned int	offset;\n"
	       "	unsigned int	type;\n"
	       "	long		addend;\n"
	       "	long		value;\n"
	       "} %s;\n%s %s[] = {\n",
	       opts->type_name, opts->type_name, opts->var_name);

	pr_debug("Relocations\n------------\n");
	for (i = 0; i < hdr->e_shnum; i++) {
		Elf32_Shdr *sh = sec_hdrs[i];
		Elf32_Shdr *sh_rel;

		if (sh->sh_type != SHT_REL && sh->sh_type != SHT_RELA)
			continue;

		sh_rel = sec_hdrs[sh->sh_info];
		ptr_func_exit(sh_rel);

		pr_debug("\tsection %2d type 0x%-2x link 0x%-2x info 0x%-2x name %s\n", i,
			 sh->sh_type, sh->sh_link, sh->sh_info, &secstrings[sh->sh_name]);

		for (k = 0; k < sh->sh_size / sh->sh_entsize; k++) {
			s32 addend, place, value;
			Elf32_Shdr *sh_src;
			const char *name;
			Elf32_Sym *sym;
			void *where;
			union {
				Elf32_Rel rel;
				Elf32_Rela rela;
			} *r = mem + sh->sh_offset + sh->sh_entsize * k;
			ptr_func_exit(r);

			sym = &symbols[ELF32_R_SYM(r->rel.r_info)];
			ptr_func_exit(sym);
			name = &symstrings[sym->st_name];
			ptr_func_exit(name);
			where = mem + sh_rel->sh_offset + r->rel.r_offset;
			ptr_func_exit(where);
			sh_src = sec_hdrs[sym->st_shndx];
			ptr_func_exit(sh_src);

			pr_debug("\t\tr_offset 0x%-4x r_info 0x%-4x / sym 0x%-2x type 0x%-2x symsecoff 0x%-4x\n",
				 r->rel.r_offset, r->rel.r_info,
				 ELF32_R_SYM(r->rel.r_info),
				 ELF32_R_TYPE(r->rel.r_info),
				 sh_src->sh_offset);

			if (sym->st_shndx == SHN_UNDEF)
				continue;

			ptr_func_exit((mem + sh_rel->sh_offset + r->rel.r_offset));
			if (sh->sh_type == SHT_REL) {
				addend = *(s32 *)where;
			} else
				addend = r->rela.r_addend;

			place = (long)(where - mem);

			pr_debug("\t\t\tvalue 0x%-8x addend %-4d symname %s\n",
				 sym->st_value, addend, name);

			value = (s32)sh_src->sh_offset + (s32)sym->st_value;

			switch (ELF32_R_TYPE(r->rel.r_info)) {
			case R_386_32: /* Symbol + Addend */
				pr_debug("\t\t\t\tR_386_32   at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value + addend);
				pr_out("	{ .offset = 0x%-8x, .type = 0, .addend = %-4d, .value = 0x%x, },\n",
				       (unsigned int)place, addend, value);
				break;
			case R_386_PC32: /* Symbol + Addend - Place */
				pr_debug("\t\t\t\tR_386_PC32 at 0x%-4x val 0x%x\n",
					 (unsigned int)place, value + addend - place);
				/*
				 * R_386_PC32 are relative, patch them inplace.
				 */
				*((s32 *)where) = value + addend - place;
				break;
			default:
				pr_err("Unsupported relocation\n");
				goto err;
			}
		}
	}
	pr_out("};\n");
	pr_out("static size_t %s = %d;\n", opts->nrgotpcrel_name, nr_gotpcrel);

	pr_out("const char %s[] = {\n\t", opts->stream_name);
	for (i = 0; i < size; i++) {
		if (i && (i % 8) == 0)
			pr_out("\n\t");
		pr_out("0x%02x,", ((unsigned char *)mem)[i]);
	}
	pr_out("};\n");
err:
	free(sec_hdrs);
	return -1;
}

static int handle_elf(const struct opts_s *opts, char *mem, size_t size)
{
	unsigned char elf_ident32[EI_NIDENT] = {
		0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	unsigned char elf_ident64[EI_NIDENT] = {
		0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	};

	if (memcmp(mem, elf_ident32, sizeof(elf_ident32)) == 0)
		return handle_elf32(opts, mem, size);
	else if (memcmp(mem, elf_ident64, sizeof(elf_ident64)) == 0)
		return handle_elf64(opts, mem, size);

	pr_err("Unsupported Elf format detected\n");
	return -1;
}

/*
 * That;s the tool to generate patches object files.
 */
int main(int argc, char *argv[])
{
	struct stat st;
	int opt, idx;
	void *mem;
	int fd;

	static const char short_opts[] = "f:s:t:v:p:h";
	static struct option long_opts[] = {
		{ "file",	required_argument,	0, 'f' },
		{ "stream",	required_argument,	0, 's' },
		{ "type",	required_argument,	0, 't' },
		{ "variable",	required_argument,	0, 'v' },
		{ "postfix",	required_argument,	0, 'p' },
		{ "help",	required_argument,	0, 'h' },
		{ },
	};

	if (argc < 3)
		goto usage;

	while (1) {
		idx = -1;
		opt = getopt_long(argc, argv, short_opts, long_opts, &idx);
		if (opt == -1)
			break;
		switch (opt) {
		case 'f':
			opts.input_filename = optarg;
			break;
		case 's':
			opts.stream_name = optarg;
			break;
		case 't':
			opts.type_name = optarg;
			break;
		case 'v':
			opts.var_name = optarg;
			break;
		case 'p':
			opts.sym_postfix = optarg;
			break;
		case 'h':
		default:
			goto usage;
		}
	}

	fd = open(opts.input_filename, O_RDONLY);
	if (fd < 0) {
		pr_perror("Can't open file %s", opts.input_filename);
		goto err;
	}

	if (fstat(fd, &st)) {
		pr_perror("Can't stat file %s", opts.input_filename);
		goto err;
	}

	mem = mmap(NULL, st.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FILE, fd, 0);
	if (mem == MAP_FAILED) {
		pr_perror("Can't mmap file %s", opts.input_filename);
		goto err;
	}

	if (handle_elf(&opts, mem, st.st_size))
		goto err;
	return 0;
usage:
	printf("Usage: %s -f filename\n", argv[0]);
err:
	return 1;
}
